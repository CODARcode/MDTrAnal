# coding: utf-8
# Date: June 12, 2018
# Authors: Shinjae Yoo
# Description: This library process MD trajectories and provides sampled timestamp

import numpy as np
import math
import traceback

from sklearn.decomposition import TruncatedSVD
from sklearn.utils.extmath import svd_flip, randomized_svd

from scipy.sparse.linalg import svds
from scipy.misc import imfilter
import scipy.ndimage as ndi

import scipy.io

from heapq import heappush, heappop

from random import uniform

import matplotlib
import matplotlib.pyplot as plt


from pprint import pprint


# MM
import tempfile
import os
import logging
import subprocess
import cv2

class MDTrMovieMaker:
    def __init__(self, sorted_data, total_samples, al, cfg, logger=None):
        self.data = sorted_data
        pprint(total_samples)
        self.n_atoms = self.data[0][1].shape[0]
        self.total_samples = total_samples
        self.al = al # atom name list 
        self.cfg = cfg
        if logger is not None:
            self.logger = logger
        else:
            self.logger = None

    def _generate_xyz(self, tmpdirname, index, data_idx):
        with open("{0}/out-{1}.xyz".format(tmpdirname, index),"wt") as out:
            out.write("{}\n".format(self.n_atoms))
            out.write(" generated by MD-OAS\n")
            for i in range(self.n_atoms):
              out.write("  {0}\t{1}\t{2}\t{3}\n".format(self.al[i], self.data[data_idx][1][i][0],self.data[data_idx][1][i][1],self.data[data_idx][1][i][2]))

    def _generate_image(self, index, data_idx, tmpdirname):
            #print("created temporary directory: ", tmpdirname)
        self._generate_xyz(tmpdirname, index, data_idx)
        runProgram(progName="java", argStr=" -jar {0}  -g {1}x{2} -w png:out-{3}.png -s angle-script.jm -ixLo out-{3}.xyz".format(self.cfg['jmol.jar'], self.cfg['width'], self.cfg['height'], index), working_dir=tmpdirname, logger=self.logger)
        self.crr_frame = cv2.imread("{0}/out-{1}.png".format(tmpdirname,index))
        self.video.write(self.crr_frame)
            
    def create_clip(self, view_angle=None):
        self.video = cv2.VideoWriter(self.cfg['video_name'], cv2.VideoWriter_fourcc(*self.cfg['codec']), self.cfg['fps'], (self.cfg['width'],self.cfg['height']))
        data_idx = 0
        with tempfile.TemporaryDirectory() as tmpdirname: 
            with open("{0}/angle-script.jm".format(tmpdirname),"wt") as out:
              if view_angle is None:
                  out.write("\n")
              else:
                  out.write("rotate AXISANGLE {{{0} {1} {2} 45}}\n".format(view_angle[0], view_angle[1], view_angle[2]))
            for i in range(self.total_samples):
                if(data_idx < len(self.data) and i == self.data[data_idx][0]):  # assume self.data[0][0[ = 0
                    self._generate_image(i, data_idx, tmpdirname)
                    data_idx = data_idx + 1
                else:
                    self.video.write(self.crr_frame)
            self.video.release()
            self.video = None

    def create_clip_bunch(self, view_angle=None):
        self.video = cv2.VideoWriter(self.cfg['video_name'], cv2.VideoWriter_fourcc(*self.cfg['codec']), self.cfg['fps'], (self.cfg['width'],self.cfg['height']))
        #self.video = cv2.VideoWriter(self.cfg['video_name'], 0x00000021, self.cfg['fps'], (self.cfg['width'],self.cfg['height'])) # forced to use X264
        data_idx = 0

        tmpdirname = "tst"
        #with open("{0}/out-all.xyz".format(tmpdirname),"wt") as out:
        #with tempfile.TemporaryDirectory() as tmpdirname: 
        if tmpdirname is not None:
            with open("{0}/angle-script.jm".format(tmpdirname),"wt") as out:
              if view_angle is None:
                  out.write("\n")
              else:
                  out.write("rotate AXISANGLE {{{0} {1} {2} 45}}\n".format(view_angle[0], view_angle[1], view_angle[2]))
              out.write("""
ribbon on
wireframe off
spacefill off 

frame 1
num_frames = getProperty("modelInfo.modelCount")
for (var i = 1; i <= num_frames; i = i+1)
  var filename = "out-"+("00000"+i)[-4][0]+".png"
  write IMAGE """ + str(self.cfg['width']) + " " +  str(self.cfg['height']) + """ PNG @filename
  frame next
end for
""")
            out =  open("{0}/out-all.xyz".format(tmpdirname),"wt") 
            if out is not None:

                for i in range(self.total_samples):
                    if(data_idx < len(self.data) and i == self.data[data_idx][0]):  # assume self.data[0][0] = 0
                      out.write("{}\n".format(self.n_atoms))
                      out.write(" generated by MD-OAS\n")
                      for j in range(self.n_atoms):
                        out.write("  {0}\t{1}\t{2}\t{3}\n".format(self.al[j], self.data[data_idx][1][j][0],self.data[data_idx][1][j][1],self.data[data_idx][1][j][2]))
                      data_idx = data_idx + 1
                out.close()
                out =  open("{0}/preprocess.sh".format(tmpdirname),"wt") 
                out.write("""
#!/bin/bash
cat out-all.xyz | ../../work/orient-v3/orient.exe > out-all-oriented.xyz
obabel -ixyz out-all-oriented.xyz -opdb -O out-all.pdb
""")
                out.close()
                         
                runProgram(progName="/bin/bash", argStr=" preprocess.sh", working_dir=tmpdirname, logger=self.logger)
                runProgram(progName="java", argStr=" -jar {0} -g {1}x{2} -s angle-script.jm -ixLo out-all.pdb".format(self.cfg['jmol.jar'], self.cfg['width'], self.cfg['height']), working_dir=tmpdirname, logger=self.logger)
                data_idx = 0
                for i in range(self.total_samples):
                    if(data_idx < len(self.data) and i == self.data[data_idx][0]):  # assume self.data[0][0] = 0
                      if self.logger is not None:
                        self.logger.info("Processing {0}/out-{1:05d}.png".format(tmpdirname,data_idx+1))
                      self.crr_frame = cv2.imread("{0}/out-{1:05d}.png".format(tmpdirname,data_idx+1))
                      data_idx = data_idx + 1
                    self.video.write(self.crr_frame)
            self.video.release()
            self.video = None

def runProgram(logger=None,
               progName=None,
               argStr=None,
               script_dir=None,
               working_dir=None):
        """
        Convenience func to handle calling and monitoring output of external programs.
    
        :param progName: name of system program command
        :param argStr: string containing command line options for ``progName``
    
        :returns: subprocess.communicate object
        """

        # Ensure program is callable.
        if script_dir is not None:
                progPath= os.path.join(script_dir,progName)
        else:
                progPath = progName
        cmdStr = "%s %s" % (progPath,argStr)
        #print ("Executing : ",cmdStr)
        if logger is not None:
                logger.info("Executing : "+cmdStr)
        process = subprocess.Popen(cmdStr,
                               shell=True,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE,
                               cwd=working_dir)
        # Get results
        result,stderr  = process.communicate()
        if logger is not None and result is not None and len(result) > 0:
            logger.info(result)
        else:
            pass
            #print (result)
        if logger is not None and stderr is not None and len(stderr) > 0:
            logger.info(stderr)
        else:
            pass
            #print (stderr)

        # Check returncode for success/failure
        if process.returncode != 0:
                raise Exception("Command execution failed  {0}".format("".join(traceback.format_exc())))
                raise RuntimeError('Return Code : {0} , result {1} , progName {2}'.format(process.returncode,result,progName))

        # Return result
        return { "result" : result , "stderr" :stderr }



